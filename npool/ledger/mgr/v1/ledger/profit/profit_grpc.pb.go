// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.18.1
// source: npool/ledger/mgr/v1/ledger/profit/profit.proto

package profit

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ManagerClient is the client API for Manager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagerClient interface {
	CreateProfit(ctx context.Context, in *CreateProfitRequest, opts ...grpc.CallOption) (*CreateProfitResponse, error)
	CreateProfits(ctx context.Context, in *CreateProfitsRequest, opts ...grpc.CallOption) (*CreateProfitsResponse, error)
	AddProfit(ctx context.Context, in *AddProfitRequest, opts ...grpc.CallOption) (*AddProfitResponse, error)
	GetProfit(ctx context.Context, in *GetProfitRequest, opts ...grpc.CallOption) (*GetProfitResponse, error)
	GetProfitOnly(ctx context.Context, in *GetProfitOnlyRequest, opts ...grpc.CallOption) (*GetProfitOnlyResponse, error)
	GetProfits(ctx context.Context, in *GetProfitsRequest, opts ...grpc.CallOption) (*GetProfitsResponse, error)
	ExistProfit(ctx context.Context, in *ExistProfitRequest, opts ...grpc.CallOption) (*ExistProfitResponse, error)
	ExistProfitConds(ctx context.Context, in *ExistProfitCondsRequest, opts ...grpc.CallOption) (*ExistProfitCondsResponse, error)
	CountProfits(ctx context.Context, in *CountProfitsRequest, opts ...grpc.CallOption) (*CountProfitsResponse, error)
	DeleteProfit(ctx context.Context, in *DeleteProfitRequest, opts ...grpc.CallOption) (*DeleteProfitResponse, error)
}

type managerClient struct {
	cc grpc.ClientConnInterface
}

func NewManagerClient(cc grpc.ClientConnInterface) ManagerClient {
	return &managerClient{cc}
}

func (c *managerClient) CreateProfit(ctx context.Context, in *CreateProfitRequest, opts ...grpc.CallOption) (*CreateProfitResponse, error) {
	out := new(CreateProfitResponse)
	err := c.cc.Invoke(ctx, "/ledger.manager.ledger.profit.v1.Manager/CreateProfit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) CreateProfits(ctx context.Context, in *CreateProfitsRequest, opts ...grpc.CallOption) (*CreateProfitsResponse, error) {
	out := new(CreateProfitsResponse)
	err := c.cc.Invoke(ctx, "/ledger.manager.ledger.profit.v1.Manager/CreateProfits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) AddProfit(ctx context.Context, in *AddProfitRequest, opts ...grpc.CallOption) (*AddProfitResponse, error) {
	out := new(AddProfitResponse)
	err := c.cc.Invoke(ctx, "/ledger.manager.ledger.profit.v1.Manager/AddProfit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) GetProfit(ctx context.Context, in *GetProfitRequest, opts ...grpc.CallOption) (*GetProfitResponse, error) {
	out := new(GetProfitResponse)
	err := c.cc.Invoke(ctx, "/ledger.manager.ledger.profit.v1.Manager/GetProfit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) GetProfitOnly(ctx context.Context, in *GetProfitOnlyRequest, opts ...grpc.CallOption) (*GetProfitOnlyResponse, error) {
	out := new(GetProfitOnlyResponse)
	err := c.cc.Invoke(ctx, "/ledger.manager.ledger.profit.v1.Manager/GetProfitOnly", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) GetProfits(ctx context.Context, in *GetProfitsRequest, opts ...grpc.CallOption) (*GetProfitsResponse, error) {
	out := new(GetProfitsResponse)
	err := c.cc.Invoke(ctx, "/ledger.manager.ledger.profit.v1.Manager/GetProfits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) ExistProfit(ctx context.Context, in *ExistProfitRequest, opts ...grpc.CallOption) (*ExistProfitResponse, error) {
	out := new(ExistProfitResponse)
	err := c.cc.Invoke(ctx, "/ledger.manager.ledger.profit.v1.Manager/ExistProfit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) ExistProfitConds(ctx context.Context, in *ExistProfitCondsRequest, opts ...grpc.CallOption) (*ExistProfitCondsResponse, error) {
	out := new(ExistProfitCondsResponse)
	err := c.cc.Invoke(ctx, "/ledger.manager.ledger.profit.v1.Manager/ExistProfitConds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) CountProfits(ctx context.Context, in *CountProfitsRequest, opts ...grpc.CallOption) (*CountProfitsResponse, error) {
	out := new(CountProfitsResponse)
	err := c.cc.Invoke(ctx, "/ledger.manager.ledger.profit.v1.Manager/CountProfits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) DeleteProfit(ctx context.Context, in *DeleteProfitRequest, opts ...grpc.CallOption) (*DeleteProfitResponse, error) {
	out := new(DeleteProfitResponse)
	err := c.cc.Invoke(ctx, "/ledger.manager.ledger.profit.v1.Manager/DeleteProfit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagerServer is the server API for Manager service.
// All implementations must embed UnimplementedManagerServer
// for forward compatibility
type ManagerServer interface {
	CreateProfit(context.Context, *CreateProfitRequest) (*CreateProfitResponse, error)
	CreateProfits(context.Context, *CreateProfitsRequest) (*CreateProfitsResponse, error)
	AddProfit(context.Context, *AddProfitRequest) (*AddProfitResponse, error)
	GetProfit(context.Context, *GetProfitRequest) (*GetProfitResponse, error)
	GetProfitOnly(context.Context, *GetProfitOnlyRequest) (*GetProfitOnlyResponse, error)
	GetProfits(context.Context, *GetProfitsRequest) (*GetProfitsResponse, error)
	ExistProfit(context.Context, *ExistProfitRequest) (*ExistProfitResponse, error)
	ExistProfitConds(context.Context, *ExistProfitCondsRequest) (*ExistProfitCondsResponse, error)
	CountProfits(context.Context, *CountProfitsRequest) (*CountProfitsResponse, error)
	DeleteProfit(context.Context, *DeleteProfitRequest) (*DeleteProfitResponse, error)
	mustEmbedUnimplementedManagerServer()
}

// UnimplementedManagerServer must be embedded to have forward compatible implementations.
type UnimplementedManagerServer struct {
}

func (UnimplementedManagerServer) CreateProfit(context.Context, *CreateProfitRequest) (*CreateProfitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProfit not implemented")
}
func (UnimplementedManagerServer) CreateProfits(context.Context, *CreateProfitsRequest) (*CreateProfitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProfits not implemented")
}
func (UnimplementedManagerServer) AddProfit(context.Context, *AddProfitRequest) (*AddProfitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddProfit not implemented")
}
func (UnimplementedManagerServer) GetProfit(context.Context, *GetProfitRequest) (*GetProfitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfit not implemented")
}
func (UnimplementedManagerServer) GetProfitOnly(context.Context, *GetProfitOnlyRequest) (*GetProfitOnlyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfitOnly not implemented")
}
func (UnimplementedManagerServer) GetProfits(context.Context, *GetProfitsRequest) (*GetProfitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfits not implemented")
}
func (UnimplementedManagerServer) ExistProfit(context.Context, *ExistProfitRequest) (*ExistProfitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExistProfit not implemented")
}
func (UnimplementedManagerServer) ExistProfitConds(context.Context, *ExistProfitCondsRequest) (*ExistProfitCondsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExistProfitConds not implemented")
}
func (UnimplementedManagerServer) CountProfits(context.Context, *CountProfitsRequest) (*CountProfitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountProfits not implemented")
}
func (UnimplementedManagerServer) DeleteProfit(context.Context, *DeleteProfitRequest) (*DeleteProfitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProfit not implemented")
}
func (UnimplementedManagerServer) mustEmbedUnimplementedManagerServer() {}

// UnsafeManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagerServer will
// result in compilation errors.
type UnsafeManagerServer interface {
	mustEmbedUnimplementedManagerServer()
}

func RegisterManagerServer(s grpc.ServiceRegistrar, srv ManagerServer) {
	s.RegisterService(&Manager_ServiceDesc, srv)
}

func _Manager_CreateProfit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProfitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).CreateProfit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ledger.manager.ledger.profit.v1.Manager/CreateProfit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).CreateProfit(ctx, req.(*CreateProfitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_CreateProfits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProfitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).CreateProfits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ledger.manager.ledger.profit.v1.Manager/CreateProfits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).CreateProfits(ctx, req.(*CreateProfitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_AddProfit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddProfitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).AddProfit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ledger.manager.ledger.profit.v1.Manager/AddProfit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).AddProfit(ctx, req.(*AddProfitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_GetProfit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProfitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).GetProfit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ledger.manager.ledger.profit.v1.Manager/GetProfit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).GetProfit(ctx, req.(*GetProfitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_GetProfitOnly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProfitOnlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).GetProfitOnly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ledger.manager.ledger.profit.v1.Manager/GetProfitOnly",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).GetProfitOnly(ctx, req.(*GetProfitOnlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_GetProfits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProfitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).GetProfits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ledger.manager.ledger.profit.v1.Manager/GetProfits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).GetProfits(ctx, req.(*GetProfitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_ExistProfit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistProfitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).ExistProfit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ledger.manager.ledger.profit.v1.Manager/ExistProfit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).ExistProfit(ctx, req.(*ExistProfitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_ExistProfitConds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistProfitCondsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).ExistProfitConds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ledger.manager.ledger.profit.v1.Manager/ExistProfitConds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).ExistProfitConds(ctx, req.(*ExistProfitCondsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_CountProfits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountProfitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).CountProfits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ledger.manager.ledger.profit.v1.Manager/CountProfits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).CountProfits(ctx, req.(*CountProfitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_DeleteProfit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProfitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).DeleteProfit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ledger.manager.ledger.profit.v1.Manager/DeleteProfit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).DeleteProfit(ctx, req.(*DeleteProfitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Manager_ServiceDesc is the grpc.ServiceDesc for Manager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Manager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ledger.manager.ledger.profit.v1.Manager",
	HandlerType: (*ManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProfit",
			Handler:    _Manager_CreateProfit_Handler,
		},
		{
			MethodName: "CreateProfits",
			Handler:    _Manager_CreateProfits_Handler,
		},
		{
			MethodName: "AddProfit",
			Handler:    _Manager_AddProfit_Handler,
		},
		{
			MethodName: "GetProfit",
			Handler:    _Manager_GetProfit_Handler,
		},
		{
			MethodName: "GetProfitOnly",
			Handler:    _Manager_GetProfitOnly_Handler,
		},
		{
			MethodName: "GetProfits",
			Handler:    _Manager_GetProfits_Handler,
		},
		{
			MethodName: "ExistProfit",
			Handler:    _Manager_ExistProfit_Handler,
		},
		{
			MethodName: "ExistProfitConds",
			Handler:    _Manager_ExistProfitConds_Handler,
		},
		{
			MethodName: "CountProfits",
			Handler:    _Manager_CountProfits_Handler,
		},
		{
			MethodName: "DeleteProfit",
			Handler:    _Manager_DeleteProfit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "npool/ledger/mgr/v1/ledger/profit/profit.proto",
}
