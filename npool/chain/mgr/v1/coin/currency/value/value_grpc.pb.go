// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.18.1
// source: npool/chain/mgr/v1/coin/currency/value/value.proto

package value

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ManagerClient is the client API for Manager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagerClient interface {
	CreateCurrencyValue(ctx context.Context, in *CreateCurrencyValueRequest, opts ...grpc.CallOption) (*CreateCurrencyValueResponse, error)
	CreateCurrencyValues(ctx context.Context, in *CreateCurrencyValuesRequest, opts ...grpc.CallOption) (*CreateCurrencyValuesResponse, error)
	UpdateCurrencyValue(ctx context.Context, in *UpdateCurrencyValueRequest, opts ...grpc.CallOption) (*UpdateCurrencyValueResponse, error)
	GetCurrencyValue(ctx context.Context, in *GetCurrencyValueRequest, opts ...grpc.CallOption) (*GetCurrencyValueResponse, error)
	GetCurrencyValueOnly(ctx context.Context, in *GetCurrencyValueOnlyRequest, opts ...grpc.CallOption) (*GetCurrencyValueOnlyResponse, error)
	GetCurrencyValues(ctx context.Context, in *GetCurrencyValuesRequest, opts ...grpc.CallOption) (*GetCurrencyValuesResponse, error)
	ExistCurrencyValue(ctx context.Context, in *ExistCurrencyValueRequest, opts ...grpc.CallOption) (*ExistCurrencyValueResponse, error)
	ExistCurrencyValueConds(ctx context.Context, in *ExistCurrencyValueCondsRequest, opts ...grpc.CallOption) (*ExistCurrencyValueCondsResponse, error)
	CountCurrencyValues(ctx context.Context, in *CountCurrencyValuesRequest, opts ...grpc.CallOption) (*CountCurrencyValuesResponse, error)
	DeleteCurrencyValue(ctx context.Context, in *DeleteCurrencyValueRequest, opts ...grpc.CallOption) (*DeleteCurrencyValueResponse, error)
}

type managerClient struct {
	cc grpc.ClientConnInterface
}

func NewManagerClient(cc grpc.ClientConnInterface) ManagerClient {
	return &managerClient{cc}
}

func (c *managerClient) CreateCurrencyValue(ctx context.Context, in *CreateCurrencyValueRequest, opts ...grpc.CallOption) (*CreateCurrencyValueResponse, error) {
	out := new(CreateCurrencyValueResponse)
	err := c.cc.Invoke(ctx, "/chain.manager.coin.currency.value.v1.Manager/CreateCurrencyValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) CreateCurrencyValues(ctx context.Context, in *CreateCurrencyValuesRequest, opts ...grpc.CallOption) (*CreateCurrencyValuesResponse, error) {
	out := new(CreateCurrencyValuesResponse)
	err := c.cc.Invoke(ctx, "/chain.manager.coin.currency.value.v1.Manager/CreateCurrencyValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) UpdateCurrencyValue(ctx context.Context, in *UpdateCurrencyValueRequest, opts ...grpc.CallOption) (*UpdateCurrencyValueResponse, error) {
	out := new(UpdateCurrencyValueResponse)
	err := c.cc.Invoke(ctx, "/chain.manager.coin.currency.value.v1.Manager/UpdateCurrencyValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) GetCurrencyValue(ctx context.Context, in *GetCurrencyValueRequest, opts ...grpc.CallOption) (*GetCurrencyValueResponse, error) {
	out := new(GetCurrencyValueResponse)
	err := c.cc.Invoke(ctx, "/chain.manager.coin.currency.value.v1.Manager/GetCurrencyValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) GetCurrencyValueOnly(ctx context.Context, in *GetCurrencyValueOnlyRequest, opts ...grpc.CallOption) (*GetCurrencyValueOnlyResponse, error) {
	out := new(GetCurrencyValueOnlyResponse)
	err := c.cc.Invoke(ctx, "/chain.manager.coin.currency.value.v1.Manager/GetCurrencyValueOnly", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) GetCurrencyValues(ctx context.Context, in *GetCurrencyValuesRequest, opts ...grpc.CallOption) (*GetCurrencyValuesResponse, error) {
	out := new(GetCurrencyValuesResponse)
	err := c.cc.Invoke(ctx, "/chain.manager.coin.currency.value.v1.Manager/GetCurrencyValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) ExistCurrencyValue(ctx context.Context, in *ExistCurrencyValueRequest, opts ...grpc.CallOption) (*ExistCurrencyValueResponse, error) {
	out := new(ExistCurrencyValueResponse)
	err := c.cc.Invoke(ctx, "/chain.manager.coin.currency.value.v1.Manager/ExistCurrencyValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) ExistCurrencyValueConds(ctx context.Context, in *ExistCurrencyValueCondsRequest, opts ...grpc.CallOption) (*ExistCurrencyValueCondsResponse, error) {
	out := new(ExistCurrencyValueCondsResponse)
	err := c.cc.Invoke(ctx, "/chain.manager.coin.currency.value.v1.Manager/ExistCurrencyValueConds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) CountCurrencyValues(ctx context.Context, in *CountCurrencyValuesRequest, opts ...grpc.CallOption) (*CountCurrencyValuesResponse, error) {
	out := new(CountCurrencyValuesResponse)
	err := c.cc.Invoke(ctx, "/chain.manager.coin.currency.value.v1.Manager/CountCurrencyValues", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerClient) DeleteCurrencyValue(ctx context.Context, in *DeleteCurrencyValueRequest, opts ...grpc.CallOption) (*DeleteCurrencyValueResponse, error) {
	out := new(DeleteCurrencyValueResponse)
	err := c.cc.Invoke(ctx, "/chain.manager.coin.currency.value.v1.Manager/DeleteCurrencyValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagerServer is the server API for Manager service.
// All implementations must embed UnimplementedManagerServer
// for forward compatibility
type ManagerServer interface {
	CreateCurrencyValue(context.Context, *CreateCurrencyValueRequest) (*CreateCurrencyValueResponse, error)
	CreateCurrencyValues(context.Context, *CreateCurrencyValuesRequest) (*CreateCurrencyValuesResponse, error)
	UpdateCurrencyValue(context.Context, *UpdateCurrencyValueRequest) (*UpdateCurrencyValueResponse, error)
	GetCurrencyValue(context.Context, *GetCurrencyValueRequest) (*GetCurrencyValueResponse, error)
	GetCurrencyValueOnly(context.Context, *GetCurrencyValueOnlyRequest) (*GetCurrencyValueOnlyResponse, error)
	GetCurrencyValues(context.Context, *GetCurrencyValuesRequest) (*GetCurrencyValuesResponse, error)
	ExistCurrencyValue(context.Context, *ExistCurrencyValueRequest) (*ExistCurrencyValueResponse, error)
	ExistCurrencyValueConds(context.Context, *ExistCurrencyValueCondsRequest) (*ExistCurrencyValueCondsResponse, error)
	CountCurrencyValues(context.Context, *CountCurrencyValuesRequest) (*CountCurrencyValuesResponse, error)
	DeleteCurrencyValue(context.Context, *DeleteCurrencyValueRequest) (*DeleteCurrencyValueResponse, error)
	mustEmbedUnimplementedManagerServer()
}

// UnimplementedManagerServer must be embedded to have forward compatible implementations.
type UnimplementedManagerServer struct {
}

func (UnimplementedManagerServer) CreateCurrencyValue(context.Context, *CreateCurrencyValueRequest) (*CreateCurrencyValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCurrencyValue not implemented")
}
func (UnimplementedManagerServer) CreateCurrencyValues(context.Context, *CreateCurrencyValuesRequest) (*CreateCurrencyValuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCurrencyValues not implemented")
}
func (UnimplementedManagerServer) UpdateCurrencyValue(context.Context, *UpdateCurrencyValueRequest) (*UpdateCurrencyValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCurrencyValue not implemented")
}
func (UnimplementedManagerServer) GetCurrencyValue(context.Context, *GetCurrencyValueRequest) (*GetCurrencyValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrencyValue not implemented")
}
func (UnimplementedManagerServer) GetCurrencyValueOnly(context.Context, *GetCurrencyValueOnlyRequest) (*GetCurrencyValueOnlyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrencyValueOnly not implemented")
}
func (UnimplementedManagerServer) GetCurrencyValues(context.Context, *GetCurrencyValuesRequest) (*GetCurrencyValuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrencyValues not implemented")
}
func (UnimplementedManagerServer) ExistCurrencyValue(context.Context, *ExistCurrencyValueRequest) (*ExistCurrencyValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExistCurrencyValue not implemented")
}
func (UnimplementedManagerServer) ExistCurrencyValueConds(context.Context, *ExistCurrencyValueCondsRequest) (*ExistCurrencyValueCondsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExistCurrencyValueConds not implemented")
}
func (UnimplementedManagerServer) CountCurrencyValues(context.Context, *CountCurrencyValuesRequest) (*CountCurrencyValuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountCurrencyValues not implemented")
}
func (UnimplementedManagerServer) DeleteCurrencyValue(context.Context, *DeleteCurrencyValueRequest) (*DeleteCurrencyValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCurrencyValue not implemented")
}
func (UnimplementedManagerServer) mustEmbedUnimplementedManagerServer() {}

// UnsafeManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagerServer will
// result in compilation errors.
type UnsafeManagerServer interface {
	mustEmbedUnimplementedManagerServer()
}

func RegisterManagerServer(s grpc.ServiceRegistrar, srv ManagerServer) {
	s.RegisterService(&Manager_ServiceDesc, srv)
}

func _Manager_CreateCurrencyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCurrencyValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).CreateCurrencyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chain.manager.coin.currency.value.v1.Manager/CreateCurrencyValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).CreateCurrencyValue(ctx, req.(*CreateCurrencyValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_CreateCurrencyValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCurrencyValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).CreateCurrencyValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chain.manager.coin.currency.value.v1.Manager/CreateCurrencyValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).CreateCurrencyValues(ctx, req.(*CreateCurrencyValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_UpdateCurrencyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCurrencyValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).UpdateCurrencyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chain.manager.coin.currency.value.v1.Manager/UpdateCurrencyValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).UpdateCurrencyValue(ctx, req.(*UpdateCurrencyValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_GetCurrencyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrencyValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).GetCurrencyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chain.manager.coin.currency.value.v1.Manager/GetCurrencyValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).GetCurrencyValue(ctx, req.(*GetCurrencyValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_GetCurrencyValueOnly_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrencyValueOnlyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).GetCurrencyValueOnly(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chain.manager.coin.currency.value.v1.Manager/GetCurrencyValueOnly",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).GetCurrencyValueOnly(ctx, req.(*GetCurrencyValueOnlyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_GetCurrencyValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrencyValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).GetCurrencyValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chain.manager.coin.currency.value.v1.Manager/GetCurrencyValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).GetCurrencyValues(ctx, req.(*GetCurrencyValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_ExistCurrencyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistCurrencyValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).ExistCurrencyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chain.manager.coin.currency.value.v1.Manager/ExistCurrencyValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).ExistCurrencyValue(ctx, req.(*ExistCurrencyValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_ExistCurrencyValueConds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistCurrencyValueCondsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).ExistCurrencyValueConds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chain.manager.coin.currency.value.v1.Manager/ExistCurrencyValueConds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).ExistCurrencyValueConds(ctx, req.(*ExistCurrencyValueCondsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_CountCurrencyValues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountCurrencyValuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).CountCurrencyValues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chain.manager.coin.currency.value.v1.Manager/CountCurrencyValues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).CountCurrencyValues(ctx, req.(*CountCurrencyValuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Manager_DeleteCurrencyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCurrencyValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerServer).DeleteCurrencyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chain.manager.coin.currency.value.v1.Manager/DeleteCurrencyValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerServer).DeleteCurrencyValue(ctx, req.(*DeleteCurrencyValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Manager_ServiceDesc is the grpc.ServiceDesc for Manager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Manager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chain.manager.coin.currency.value.v1.Manager",
	HandlerType: (*ManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateCurrencyValue",
			Handler:    _Manager_CreateCurrencyValue_Handler,
		},
		{
			MethodName: "CreateCurrencyValues",
			Handler:    _Manager_CreateCurrencyValues_Handler,
		},
		{
			MethodName: "UpdateCurrencyValue",
			Handler:    _Manager_UpdateCurrencyValue_Handler,
		},
		{
			MethodName: "GetCurrencyValue",
			Handler:    _Manager_GetCurrencyValue_Handler,
		},
		{
			MethodName: "GetCurrencyValueOnly",
			Handler:    _Manager_GetCurrencyValueOnly_Handler,
		},
		{
			MethodName: "GetCurrencyValues",
			Handler:    _Manager_GetCurrencyValues_Handler,
		},
		{
			MethodName: "ExistCurrencyValue",
			Handler:    _Manager_ExistCurrencyValue_Handler,
		},
		{
			MethodName: "ExistCurrencyValueConds",
			Handler:    _Manager_ExistCurrencyValueConds_Handler,
		},
		{
			MethodName: "CountCurrencyValues",
			Handler:    _Manager_CountCurrencyValues_Handler,
		},
		{
			MethodName: "DeleteCurrencyValue",
			Handler:    _Manager_DeleteCurrencyValue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "npool/chain/mgr/v1/coin/currency/value/value.proto",
}
