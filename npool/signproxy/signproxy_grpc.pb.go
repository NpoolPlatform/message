// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package signproxy

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SignProxyClient is the client API for SignProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SignProxyClient interface {
	FromPluginToProxy(ctx context.Context, opts ...grpc.CallOption) (SignProxy_FromPluginToProxyClient, error)
	FromProxyToPlugin(ctx context.Context, opts ...grpc.CallOption) (SignProxy_FromProxyToPluginClient, error)
	Transaction(ctx context.Context, opts ...grpc.CallOption) (SignProxy_TransactionClient, error)
}

type signProxyClient struct {
	cc grpc.ClientConnInterface
}

func NewSignProxyClient(cc grpc.ClientConnInterface) SignProxyClient {
	return &signProxyClient{cc}
}

func (c *signProxyClient) FromPluginToProxy(ctx context.Context, opts ...grpc.CallOption) (SignProxy_FromPluginToProxyClient, error) {
	stream, err := c.cc.NewStream(ctx, &SignProxy_ServiceDesc.Streams[0], "/sphinx.proxy.v1.SignProxy/FromPluginToProxy", opts...)
	if err != nil {
		return nil, err
	}
	x := &signProxyFromPluginToProxyClient{stream}
	return x, nil
}

type SignProxy_FromPluginToProxyClient interface {
	Send(*FromPluginToProxyResponse) error
	Recv() (*FromPluginToProxyRequest, error)
	grpc.ClientStream
}

type signProxyFromPluginToProxyClient struct {
	grpc.ClientStream
}

func (x *signProxyFromPluginToProxyClient) Send(m *FromPluginToProxyResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *signProxyFromPluginToProxyClient) Recv() (*FromPluginToProxyRequest, error) {
	m := new(FromPluginToProxyRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *signProxyClient) FromProxyToPlugin(ctx context.Context, opts ...grpc.CallOption) (SignProxy_FromProxyToPluginClient, error) {
	stream, err := c.cc.NewStream(ctx, &SignProxy_ServiceDesc.Streams[1], "/sphinx.proxy.v1.SignProxy/FromProxyToPlugin", opts...)
	if err != nil {
		return nil, err
	}
	x := &signProxyFromProxyToPluginClient{stream}
	return x, nil
}

type SignProxy_FromProxyToPluginClient interface {
	Send(*FromProxyToPluginResponse) error
	Recv() (*FromProxyToPluginRequest, error)
	grpc.ClientStream
}

type signProxyFromProxyToPluginClient struct {
	grpc.ClientStream
}

func (x *signProxyFromProxyToPluginClient) Send(m *FromProxyToPluginResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *signProxyFromProxyToPluginClient) Recv() (*FromProxyToPluginRequest, error) {
	m := new(FromProxyToPluginRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *signProxyClient) Transaction(ctx context.Context, opts ...grpc.CallOption) (SignProxy_TransactionClient, error) {
	stream, err := c.cc.NewStream(ctx, &SignProxy_ServiceDesc.Streams[2], "/sphinx.proxy.v1.SignProxy/Transaction", opts...)
	if err != nil {
		return nil, err
	}
	x := &signProxyTransactionClient{stream}
	return x, nil
}

type SignProxy_TransactionClient interface {
	Send(*TransactionResponse) error
	Recv() (*TransactionRequest, error)
	grpc.ClientStream
}

type signProxyTransactionClient struct {
	grpc.ClientStream
}

func (x *signProxyTransactionClient) Send(m *TransactionResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *signProxyTransactionClient) Recv() (*TransactionRequest, error) {
	m := new(TransactionRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SignProxyServer is the server API for SignProxy service.
// All implementations must embed UnimplementedSignProxyServer
// for forward compatibility
type SignProxyServer interface {
	FromPluginToProxy(SignProxy_FromPluginToProxyServer) error
	FromProxyToPlugin(SignProxy_FromProxyToPluginServer) error
	Transaction(SignProxy_TransactionServer) error
	mustEmbedUnimplementedSignProxyServer()
}

// UnimplementedSignProxyServer must be embedded to have forward compatible implementations.
type UnimplementedSignProxyServer struct {
}

func (UnimplementedSignProxyServer) FromPluginToProxy(SignProxy_FromPluginToProxyServer) error {
	return status.Errorf(codes.Unimplemented, "method FromPluginToProxy not implemented")
}
func (UnimplementedSignProxyServer) FromProxyToPlugin(SignProxy_FromProxyToPluginServer) error {
	return status.Errorf(codes.Unimplemented, "method FromProxyToPlugin not implemented")
}
func (UnimplementedSignProxyServer) Transaction(SignProxy_TransactionServer) error {
	return status.Errorf(codes.Unimplemented, "method Transaction not implemented")
}
func (UnimplementedSignProxyServer) mustEmbedUnimplementedSignProxyServer() {}

// UnsafeSignProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SignProxyServer will
// result in compilation errors.
type UnsafeSignProxyServer interface {
	mustEmbedUnimplementedSignProxyServer()
}

func RegisterSignProxyServer(s grpc.ServiceRegistrar, srv SignProxyServer) {
	s.RegisterService(&SignProxy_ServiceDesc, srv)
}

func _SignProxy_FromPluginToProxy_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SignProxyServer).FromPluginToProxy(&signProxyFromPluginToProxyServer{stream})
}

type SignProxy_FromPluginToProxyServer interface {
	Send(*FromPluginToProxyRequest) error
	Recv() (*FromPluginToProxyResponse, error)
	grpc.ServerStream
}

type signProxyFromPluginToProxyServer struct {
	grpc.ServerStream
}

func (x *signProxyFromPluginToProxyServer) Send(m *FromPluginToProxyRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *signProxyFromPluginToProxyServer) Recv() (*FromPluginToProxyResponse, error) {
	m := new(FromPluginToProxyResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SignProxy_FromProxyToPlugin_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SignProxyServer).FromProxyToPlugin(&signProxyFromProxyToPluginServer{stream})
}

type SignProxy_FromProxyToPluginServer interface {
	Send(*FromProxyToPluginRequest) error
	Recv() (*FromProxyToPluginResponse, error)
	grpc.ServerStream
}

type signProxyFromProxyToPluginServer struct {
	grpc.ServerStream
}

func (x *signProxyFromProxyToPluginServer) Send(m *FromProxyToPluginRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *signProxyFromProxyToPluginServer) Recv() (*FromProxyToPluginResponse, error) {
	m := new(FromProxyToPluginResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SignProxy_Transaction_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SignProxyServer).Transaction(&signProxyTransactionServer{stream})
}

type SignProxy_TransactionServer interface {
	Send(*TransactionRequest) error
	Recv() (*TransactionResponse, error)
	grpc.ServerStream
}

type signProxyTransactionServer struct {
	grpc.ServerStream
}

func (x *signProxyTransactionServer) Send(m *TransactionRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *signProxyTransactionServer) Recv() (*TransactionResponse, error) {
	m := new(TransactionResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SignProxy_ServiceDesc is the grpc.ServiceDesc for SignProxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SignProxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sphinx.proxy.v1.SignProxy",
	HandlerType: (*SignProxyServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "FromPluginToProxy",
			Handler:       _SignProxy_FromPluginToProxy_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "FromProxyToPlugin",
			Handler:       _SignProxy_FromProxyToPlugin_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Transaction",
			Handler:       _SignProxy_Transaction_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "npool/signproxy/signproxy.proto",
}
